:toc: left
:toclevels: 8
:nofooter:
:root: ..
:consumer: {root}/consumer
:producer: {root}/producer

= Spring Cloud Contract Workshops

This documentation will allow you to go through Spring Cloud Contract Workshops by completing
a series of tasks that will teach you the basic and more advanced concept behind Consumer Driven Contracts
and Spring Cloud Contract as such.

== Workshop setup

The repository mostly consists of pairs of `producer` and `consumer` applications that show
different use cases of Spring Cloud Contract. The initial state of the repository
is such that all the examples are working and the tests are passing. In order for you to prepare
the repository so it has only the basic pieces of code set up execute this Gradle command

[source,groovy]
----
./gradlew prepareForWorkshops
----

This command will remove most of the code / contracts / project setup so that you can start
with the workshops.

TIP: Whenever your lost - don't worry. It's enough to check what's there in the `master` branch
where all of the examples are ready and working.

TIP: You can start with any task - you don't have to do them in the provided order.

== Workshop resources

- Introduction to Consumer Driven Contracts
- Introduction to Spring Cloud Contract

== Workshop scenarios

We'll be in most cases trying to code the following scenarios:

image::images/beer_1.png[title="Positive beer selling via HTTP"]

{nbsp}
{nbsp}

image::images/beer_2.png[title="Negative beer selling via HTTP"]

{nbsp}
{nbsp}

image::images/msg_1.png[title="Positive age verification via messaging"]

{nbsp}
{nbsp}

image::images/msg_2.png[title="Negative age verification via messaging"]

{nbsp}
{nbsp}

== Workshop tasks

- Contracts on the producer side (in pairs)
  * simple DSL examples for HTTP & Messaging
- Contracts that lay in an external repository (in pairs)
  * simple DSL examples for HTTP & Messaging
- Spring Cloud Contract with Rest Docs (in pairs)
  * generating stubs using Rest Docs
  * generating contracts using Rest Docs
- Contracts on the producer side (single person teams)
  * more sophisticated DSL manipulations (regexs, code execution, referencing request from response)
  * working with stub and test matchers
  * contracts representing scenarios (stateful stubs)
  * creating a library with common code shareable between teams
  * stubbing out service discovery
  * stubs per consumer feature
  * classpath scanning
  * using JUnit rule
- Stub Runner Boot


=== Contracts on the producer side

Consumer Driven Contract is like TDD on the layer of architecture. Let's start with writing a test on the
consumer side.

- Open in your IDE the `consumer` project (either via Maven or Gradle)
- Open the `BeerControllerTest` test. Since CDC is like TDD we have 2 tests that describe our beer selling features.
- We have two objectives for HTTP
  * when a client wants a beer and has
  e.g. name "marcin" and age 22 - the answer that we'll respond with `THERE YOU GO`
  * when a client is an underage and wants a beer and has
  e.g. name "marcin" and age 17 - the answer that we'll respond with `GET LOST`
- and we have two objectives for messaging
  * when a verification message with `eligible` field equal to `true` was sent to the `verifications` channel
  then we increment the `eligible` counter
  * when a verification message with `eligible` field equal to `false was sent to the `verifications` channel
  then we increment the `notEligible` counter
- Let's start with HTTP. Open the `BeerController` class. We're already providing some basic setup for you (in real TDD
example you'd have to code all of that yourself)
- Technically speaking for both cases we want to use MockMvc to send a request to the `/beer` endpoint
with a JSON pojo containing `name` and `age`. From the controller we want to send a request to
`http://localhost:8090/` where the producer will be waiting for out requests.
- The problem is such that we don't yet know what API we would like to have... This is where we touch
 the very essence of Consumer Driven Contracts. As consumers we want to drive the change of the API
 that's why, *as consumers*, we will work on the producer code. Open the `producer` project in your
 IDE (we simulate the case where you've cloned the producer code)
- Time to play with the API! Create a `src/test/resources/contracts/beer/rest` and
 `src/test/resources/contracts/beer/messaging` folders. (<<_proposal_of_simple_contracts,Show solution>>)
  * You can define the contracts using Groovy DSL. Let's create our first HTTP contract.
  * Under the `rest` folder create a file `shouldGrantABeerIfOldEnough.groovy`
  * Call the `org.springframework.cloud.contract.spec.Contract.make { }` method to start defining the contract
  * You can call `description()` method to provide some meaningful description. TIP: You can use the
   Groovy multiline String `""" """` to have all special characters escaped. Every new line in the String
   will be converted into a new line character
  * Now call the `request { }` and `response { }` methods
  * Let's assume that we're interested in sending a `POST` method. Call `method POST()` or `method "POST"`.
  TIP: In Groovy you don't need to provide parentheses (in most cases). You can write either `method POST()`
  or `method(POST())`. In both cases it's the same syntax
  * Now we need to provide some URL. Let it be `/check`. Let's write `url "/check"`
  * Now time to define some body. We'll leverage some of the Groovy power over here so if you're lost
  you can always check the http://groovy-lang.org/json.html[Groovy JSON documentation]. Let's call the
  `body()` method with brackets.
  * In Groovy you can use the map notation in such a way `[key: "value", secondKey: 2]`. In the same way
  we can describe the body of a JSON. So in order to send a JSON looking like this `{ "age": 22, "name": "marcin" }`
  we can create a map notation of `[age:22, name:"marcin"]`. The `body` method accepts a map and in Groovy
  if a method accepts a map then the `[]` brackets can be omited. So you can either write
  `body([age:22, name:"marcin"])` or `body(age:22, name:"marcin")`. The latter one contains less boilerplate
  code so let's write that one
  * Now time for the headers... Call the `headers { }` method
  * Inside that method let's define that we want to use the `Content-Type: "application/json` header. Just
  call `contentType(applicationJson())` methods
  * Congratulations! You defined how you would like the contract for the request to look like! Time for the
  response
  * In the `response` block we would like to define that that the status of our response will be 200.
  Just call `status 200`
  * We'd like our response to have some body. As you could have assumed there's a `body` method here too.
  We'll now use another way of defining bodies (which is the less preferred option in Spring Cloud Contract
  but still can be useful) - using String
  * We're assuming that we would like to send back a field called `status` that will return `OK` when the
  person can get the beer
  * Call the `body(""" { "status" : "OK" } """)`. That way you're defining how the response body will look like
  by providing the exact JSON value
  * Last thing to add are the response headers. We're doing exactly the same thing as we have done previously
  for the request. `headers { contentType(applicationJson()) }`.
  * Congratulations! You have created your first contract!
- Time for you to create the second contract. Create a file called `shouldRejectABeerIfTooYoung.groovy`.
If you're lost just check out the <<_proposal_of_simple_contracts,solution>>
  * Set the `age` in the request to `17`
  * Update the response body to return a `status` equal to `NOT_OK`.
  * Update the description
- Now it's time to turn on the magic! Let's add the Spring Cloud Starter Contract Stub Runner dependency.
<<_adding_spring_cloud_contract_stub_runner,Show solution>>

== Solutions

=== Proposal of simple contracts

*HTTP communication*

[source,groovy,indent=0,subs="verbatim,attributes",role="primary"]
.Old Enough
----
// rest/shouldGrantABeerIfOldEnough.groovy
org.springframework.cloud.contract.spec.Contract.make {
		description("""
Represents a successful scenario of getting a beer

```
given:
	client is old enough
when:
	he applies for a beer
then:
	we'll grant him the beer
```

""")
	request {
		method 'POST'
		url '/check'
		body(
				age: 22,
				name: "marcin"
		)
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status 200
		body("""
			{
				"status": "OK"
			}
			""")
		headers {
			contentType(applicationJson())
		}
	}
}
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Too Young
----
// rest/shouldRejectABeerIfTooYoung.groovy
org.springframework.cloud.contract.spec.Contract.make {
		description("""
Represents a successful scenario of getting a beer

```
given:
	client is old enough
when:
	he applies for a beer
then:
	we'll grant him the beer
```

""")
	request {
		method 'POST'
		url '/check'
		body(
				age: 17,
				name: "marcin"
		)
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status 200
		body("""
			{
				"status": "NOT_OK"
			}
			""")
		headers {
			contentType(applicationJson())
		}
	}
}
----

*Messaging communication*

[source,groovy,indent=0,subs="verbatim,attributes",role="primary"]
.Positive Verification
----
// messaging/shouldSendAcceptedVerification.groovy
org.springframework.cloud.contract.spec.Contract.make {
	description("""
Sends a positive verification message when person is eligible to get the beer

```
given:
	client is old enough
when:
	he applies for a beer
then:
	we'll send a message with a positive verification
```

""")
	// Label by means of which the output message can be triggered
	label 'accepted_verification'
	input {
		// the contract will be triggered by a method - as consumers at this moment we
		// don't care how
		triggeredBy('')
	}
	// output message of the contract
	outputMessage {
		// destination to which the output message will be sent
		sentTo 'verifications'
		// the body of the output message
		body([
				eligible: true
		])
	}
}
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Negative Verification
----
// messaging/shouldSendRejectedVerification.groovy
org.springframework.cloud.contract.spec.Contract.make {
	description("""
Sends a negative verification message when person is not eligible to get the beer

```
given:
	client is too young
when:
	he applies for a beer
then:
	we'll send a message with a negative verification
```

""")
	// Label by means of which the output message can be triggered
	label 'rejected_verification'
	// input to the contract
	input {
		// the contract will be triggered by a method - as consumers at this moment we
		// don't care how
		triggeredBy('')
	}
	// output message of the contract
	outputMessage {
		// destination to which the output message will be sent
		sentTo 'verifications'
		// the body of the output message
		body([
				eligible: false
		])
	}
}
----

=== Adding Spring Cloud Contract Stub Runner

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
include::{consumer}/pom.xml[tags=stubrunner]
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
include::{consumer}/build.gradle[tags=stubrunner]
----